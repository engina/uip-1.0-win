<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Exported functions</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Exported functions<br>
<small>
[<a class="el" href="group__wpcap.html">WinPcap user's manual</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Unix-compatible Functions</h2></td></tr>
<tr><td colspan=2>These functions are part of the libpcap library, and therefore work both on Windows and on Linux. <dl compact><dt><b>Note:</b></dt><dd>errbuf in <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga5">pcap_setnonblock()</a>, <a class="el" href="group__wpcapfunc.html#ga6">pcap_getnonblock()</a>, <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga9">pcap_lookupdev()</a>, and <a class="el" href="group__wpcapfunc.html#ga10">pcap_lookupnet()</a> is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars. </dd></dl>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef void(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a> )(u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of the callback function that receives the packets.  <a href="#ga0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live</a> (const char *device, int snaplen, int promisc, int to_ms, char *ebuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a live capture from the network.  <a href="#ga1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead</a> (int linktype, int snaplen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pcap_t structure without starting a capture.  <a href="#ga2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline</a> (const char *fname, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a savefile in the tcpdump/libpcap format to read packets.  <a href="#ga3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, const char *fname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a file to write packets.  <a href="#ga4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga5">pcap_setnonblock</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int nonblock, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch between blocking and nonblocking mode.  <a href="#ga5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga6">pcap_getnonblock</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the "non-blocking" state of an interface.  <a href="#ga6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs</a> (<a class="el" href="structpcap__if.html">pcap_if_t</a> **alldevsp, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>.  <a href="#ga7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a> (<a class="el" href="structpcap__if.html">pcap_if_t</a> *alldevsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an interface list returned by <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>.  <a href="#ga8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga9">pcap_lookupdev</a> (char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first valid device in the system.  <a href="#ga9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga10">pcap_lookupnet</a> (const char *device, <a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> *netp, <a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> *maskp, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the subnet and netmask of an interface.  <a href="#ga10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a> callback, u_char *user)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect a group of packets.  <a href="#ga11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga12">pcap_loop</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a> callback, u_char *user)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect a group of packets.  <a href="#ga12"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga13">pcap_next</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next available packet.  <a href="#ga13"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga14">pcap_next_ex</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, const u_char **pkt_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a packet from an interface or from an offline capture.  <a href="#ga14"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a flag that will force <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> to return rather than looping.  <a href="#ga15"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga16">pcap_sendpacket</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, u_char *buf, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a raw packet.  <a href="#ga16"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga17">pcap_dump</a> (u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h, const u_char *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a packet to disk.  <a href="#ga17"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga18">pcap_dump_ftell</a> (<a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the file position for a "savefile".  <a href="#ga18"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga19">pcap_compile</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, struct bpf_program *fp, char *str, int optimize, <a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> netmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile a packet filter, converting an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine.  <a href="#ga19"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap</a> (int snaplen_arg, int linktype_arg, struct bpf_program *program, char *buf, int optimize, <a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile a packet filter without the need of opening an adapter. This function converts an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine.  <a href="#ga20"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, struct bpf_program *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate a filter to a capture.  <a href="#ga21"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga22">pcap_freecode</a> (struct bpf_program *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a filter.  <a href="#ga22"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga23">pcap_datalink</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the link layer of an adapter.  <a href="#ga23"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga24">pcap_list_datalinks</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int **dlt_buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list datalinks  <a href="#ga24"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga25">pcap_set_datalink</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int dlt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure.  <a href="#ga25"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga26">pcap_datalink_name_to_val</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding data link type value. The translation is case-insensitive. -1 is returned on failure.  <a href="#ga26"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga27">pcap_datalink_val_to_name</a> (int dlt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates a data link type value to the corresponding data link type name. NULL is returned on failure.  <a href="#ga27"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga28">pcap_datalink_val_to_description</a> (int dlt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates a data link type value to a short description of that data link type. NULL is returned on failure.  <a href="#ga28"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga29">pcap_snapshot</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of the packet portion (in bytes) that is delivered to the application.  <a href="#ga29"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga30">pcap_is_swapped</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the current savefile uses a different byte order than the current system.  <a href="#ga30"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga31">pcap_major_version</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the major version number of the pcap library used to write the savefile.  <a href="#ga31"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga32">pcap_minor_version</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the minor version number of the pcap library used to write the savefile.  <a href="#ga32"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>FILE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga33">pcap_file</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the standard stream of an offline capture.  <a href="#ga33"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga34">pcap_stats</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return statistics on current capture.  <a href="#ga34"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga35">pcap_perror</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, char *prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print the text of the last pcap library error on stderr, prefixed by prefix.  <a href="#ga35"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the error text pertaining to the last pcap library error.  <a href="#ga36"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga37">pcap_strerror</a> (int error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provided in case strerror() isn't available.  <a href="#ga37"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga38">pcap_lib_version</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number.  <a href="#ga38"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga39">pcap_close</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">close the files associated with p and deallocates resources.  <a href="#ga39"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>FILE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga40">pcap_dump_file</a> (<a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the standard I/O stream of the 'savefile' opened by <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>.  <a href="#ga40"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga41">pcap_dump_flush</a> (<a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flushes the output buffer to the ``savefile,'' so that any packets written with <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> but not yet written to the ``savefile'' will be written. -1 is returned on error, 0 on success.  <a href="#ga41"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga42">pcap_dump_close</a> (<a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a savefile.  <a href="#ga42"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Windows-specific Extensions</h2></td></tr>
<tr><td colspan=2>The functions in this section extend libpcap to offer advanced functionalities (like remote packet capture, packet buffer size variation or high-precision packet injection). Howerver, at the moment they can be used only in Windows. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga43">pcap_offline_filter</a> (struct bpf_program *prog, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, const u_char *pkt_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if a given filter applies to an offline packet.  <a href="#ga43"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, char *filename, int maxsize, int maxpacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a capture to file.  <a href="#ga44"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int sync)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the kernel dump process, i.e. tells if one of the limits defined with <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> has been reached.  <a href="#ga45"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga46">pcap_stats_ex</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int *pcap_stat_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return statistics on current capture.  <a href="#ga46"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga47">pcap_setbuff</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the size of the kernel buffer associated with an adapter.  <a href="#ga47"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga48">pcap_setmode</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the working mode of the interface p to mode.  <a href="#ga48"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga49">pcap_setmintocopy</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the minumum amount of data received by the kernel in a single call.  <a href="#ga49"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HANDLE&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga50">pcap_getevent</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle of the event associated with the interface p.  <a href="#ga50"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga51">pcap_sendqueue_alloc</a> (u_int memsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a send queue.  <a href="#ga51"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga52">pcap_sendqueue_destroy</a> (<a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a send queue.  <a href="#ga52"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue</a> (<a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a packet to a send queue.  <a href="#ga53"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>u_int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga54">pcap_sendqueue_transmit</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p, <a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue, int sync)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a queue of raw packets to the network.  <a href="#ga54"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex</a> (char *source, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, <a class="el" href="structpcap__if.html">pcap_if_t</a> **alldevs, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>.  <a href="#ga55"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga56">pcap_createsrcstr</a> (char *source, int type, const char *<a class="el" href="wpcap__remote_8htm.html#a2">host</a>, const char *port, const char *name, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').  <a href="#ga56"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga57">pcap_parsesrcstr</a> (const char *source, int *type, char *<a class="el" href="wpcap__remote_8htm.html#a2">host</a>, char *port, char *name, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the source string and returns the pieces in which the source can be split.  <a href="#ga57"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga58">pcap_open</a> (const char *source, int snaplen, int flags, int read_timeout, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a generic source in order to capture / send (WinPcap only) traffic.  <a href="#ga58"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structpcap__samp.html">pcap_samp</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga59">pcap_setsampling</a> (<a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a sampling method for packet capture.  <a href="#ga59"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>SOCKET&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga60">pcap_remoteact_accept</a> (const char *address, const char *port, const char *hostlist, char *connectinghost, struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *auth, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until a network connection is accepted (active mode only).  <a href="#ga60"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga61">pcap_remoteact_close</a> (const char *<a class="el" href="wpcap__remote_8htm.html#a2">host</a>, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop an active connection (active mode only).  <a href="#ga61"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga62">pcap_remoteact_cleanup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean the socket that is currently used in waiting active connections.  <a href="#ga62"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__wpcapfunc.html#ga63">pcap_remoteact_list</a> (char *hostlist, char sep, int size, char *errbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the hostname of the host that have an active connection with us (active mode only).  <a href="#ga63"></a><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions exported by wpcap.dll <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="funcs/pcap.h::pcap_handler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef void(* <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a>)(u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of the callback function that receives the packets. 
<p>
When <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> are called by the user, the packets are passed to the application by means of this callback. user is a user-defined parameter that contains the state of the capture session, it corresponds to the <em>user</em> parameter of <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> and <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>. pkt_header is the header associated by the capture driver to the packet. It is NOT a protocol header. pkt_data points to the data of the packet, including the protocol headers. 
<p>
Definition at line <a class="el" href="funcs_2pcap_8h-source.html#l00027">27</a> of file <a class="el" href="funcs_2pcap_8h-source.html">funcs/pcap.h</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga15" doxytag="funcs/pcap.h::pcap_breakloop" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_breakloop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set a flag that will force <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> to return rather than looping. 
<p>
They will return the number of packets that have been processed so far, or -2 if no packets have been processed so far. This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop. The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a> in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal. Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a>, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes. <dl compact><dt><b>Note:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a> will, on some platforms, loop reading packets from the OS; that loop will not necessarily be terminated by a signal, so <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a> should be used to terminate packet processing even if <a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a> is being used. <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a> does not guarantee that no further packets will be processed by <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> after it is called; at most one more packet might be processed. If -2 is returned from <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>, the flag is cleared, so a subsequent call will resume reading packets. If a positive number is returned, the flag is not cleared, so a subsequent call will return -2 and clear the flag. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga39" doxytag="funcs/pcap.h::pcap_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
close the files associated with p and deallocates resources. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="funcs/pcap.h::pcap_compile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_compile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct bpf_program *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optimize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>netmask</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compile a packet filter, converting an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine. 
<p>
<a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a> is used to compile the string str into a filter program. program is a pointer to a bpf_program struct and is filled in by <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>. optimize controls whether optimization on the resulting code is performed. netmask specifies the IPv4 netmask of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the netmask of the network on which packets are being captured isn't known to the program, or if packets are being captured on the Linux "any" pseudo-interface that can capture on more than one network, a value of 0 can be supplied; tests for IPv4 broadcast addreses won't be done correctly, but all other tests in the filter program will be OK. A return of -1 indicates an error in which case <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> may be used to display the error text.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#ga22">pcap_freecode()</a>, <a class="el" href="group__wpcapfunc.html#ga29">pcap_snapshot()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="funcs/pcap.h::pcap_compile_nopcap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_compile_nopcap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>snaplen_arg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>linktype_arg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct bpf_program *&nbsp;</td>
          <td class="mdname" nowrap> <em>program</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>optimize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compile a packet filter without the need of opening an adapter. This function converts an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine. 
<p>
<a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> is similar to <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a> except that instead of passing a pcap structure, one passes the snaplen and linktype explicitly. It is intended to be used for compiling filters for direct BPF usage, without necessarily having called <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>. A return of -1 indicates an error; the error text is unavailable. (<a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> is a wrapper around <a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>, and <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a>; the latter three routines can be used directly in order to get the error text for a compilation error.)<p>
Look at the <a class="el" href="group__language.html">Filtering expression syntax</a> section for details on the str parameter.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#ga22">pcap_freecode()</a>, <a class="el" href="group__wpcapfunc.html#ga29">pcap_snapshot()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga56" doxytag="funcs/pcap.h::pcap_createsrcstr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_createsrcstr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accept a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0'). 
<p>
This function is provided in order to help the user creating the source string according to the new format. An unique source string is used in order to make easy for old applications to use the remote facilities. Think about tcpdump, for example, which has only one way to specify the interface on which the capture has to be started. However, GUI-based programs can find more useful to specify hostname, port and interface name separately. In that case, they can use this function to create the source string before passing it to the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>source:</em>&nbsp;</td><td>a user-allocated buffer that will contain the complete source string wen the function returns.<br>
 The source will start with an identifier according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.<br>
 This function assumes that the allocated buffer is at least PCAP_BUF_SIZE bytes.</td></tr>
    <tr><td></td><td valign=top><em>type:</em>&nbsp;</td><td>its value tells the type of the source we want to create. It can assume the values defined in the <a class="el" href="group__remote__source__ID.html">Source identification Codes </a>.<br>
</td></tr>
    <tr><td></td><td valign=top><em>host:</em>&nbsp;</td><td>an user-allocated buffer that keeps the host (e.g. "foo.bar.com") we want to connect to. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td></td><td valign=top><em>port:</em>&nbsp;</td><td>an user-allocated buffer that keeps the network port (e.g. "2002") we want to use for the RPCAP protocol. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td></td><td valign=top><em>name:</em>&nbsp;</td><td>an user-allocated buffer that keeps the interface name we want to use (e.g. "eth0"). It can be NULL in case the return string (i.e. 'source') has to be used with the <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a>, which does not require the interface name.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The string containing the complete source is returned in the 'source' variable.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>If the source is longer than PCAP_BUF_SIZE, the excess characters are truncated. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="funcs/pcap.h::pcap_datalink" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_datalink           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the link layer of an adapter. 
<p>
returns the link layer type; link layer types it can return include:<p>
<ul>
<li>DLT_NULL BSD loopback encapsulation; the link layer header is a 4-byte field, in host byte order, containing a PF_ value from socket.h for the network-layer protocol of the packet. Note that ``host byte order'' is the byte order of the machine on which the packets are captured, and the PF_ values are for the OS of the machine on which the packets are captured; if a live capture is being done, ``host byte order'' is the byte order of the machine capturing the packets, and the PF_ values are those of the OS of the machine capturing the packets, but if a ``savefile'' is being read, the byte order and PF_ values are not necessarily those of the machine reading the capture file.</li><li>DLT_EN10MB Ethernet (10Mb, 100Mb, 1000Mb, and up)</li><li>DLT_IEEE802: IEEE 802.5 Token Ring</li><li>DLT_ARCNET: ARCNET</li><li>DLT_SLIP: SLIP; the link layer header contains, in order:<ol>
<li>a 1-byte flag, which is 0 for packets received by the machine and 1 for packets sent by the machine;</li><li>a 1-byte field, the upper 4 bits of which indicate the type of packet, as per RFC 1144:<ul>
<li>0x40: an unmodified IP datagram (TYPE_IP);</li><li>0x70: an uncompressed-TCP IP datagram (UNCOMPRESSED_TCP), with that byte being the first byte of the raw IP header on the wire, containing the connection number in the protocol field;</li><li>0x80: a compressed-TCP IP datagram (COMPRESSED_TCP), with that byte being the first byte of the compressed TCP/IP datagram header;</li></ul>
</li><li>for UNCOMPRESSED_TCP, the rest of the modified IP header, and for COMPRESSED_TCP, the compressed TCP/IP datagram header;</li><li>for a total of 16 bytes; the uncompressed IP datagram follows the header.</li></ol>
</li></ul>
<p>
<ul>
<li>DLT_PPP: PPP; if the first 2 bytes are 0xff and 0x03, it's PPP in HDLC-like framing, with the PPP header following those two bytes, otherwise it's PPP without framing, and the packet begins with the PPP header.</li><li>DLT_FDDI: FDDI</li><li>DLT_ATM_RFC1483: RFC 1483 LLC/SNAP-encapsulated ATM; the packet begins with an IEEE 802.2 LLC header.</li><li>DLT_RAW: raw IP; the packet begins with an IP header.</li><li>DLT_PPP_SERIAL: PPP in HDLC-like framing, as per RFC 1662, or Cisco PPP with HDLC framing, as per section 4.3.1 of RFC 1547; the first byte will be 0xFF for PPP in HDLC-like framing, and will be 0x0F or 0x8F for Cisco PPP with HDLC framing.</li><li>DLT_PPP_ETHER: PPPoE; the packet begins with a PPPoE header, as per RFC 2516.</li><li>DLT_C_HDLC: Cisco PPP with HDLC framing, as per section 4.3.1 of RFC 1547.</li><li>DLT_IEEE802_11: IEEE 802.11 wireless LAN</li><li>DLT_FRELAY: Frame Relay</li><li>DLT_LOOP: OpenBSD loopback encapsulation; the link layer header is a 4-byte field, in network byte order, containing a PF_ value from OpenBSD's socket.h for the network-layer protocol of the packet. Note that, if a ``savefile'' is being read, those PF_ values are not necessarily those of the machine reading the capture file.</li><li>DLT_LINUX_SLL: Linux "cooked" capture encapsulation; the link layer header contains, in order:<ul>
<li>a 2-byte "packet type", in network byte order, which is one of:<ol>
<li>packet was sent to us by somebody else</li><li>packet was broadcast by somebody else</li><li>packet was multicast, but not broadcast, by somebody else</li><li>packet was sent by somebody else to somebody else</li><li>packet was sent by us</li></ol>
</li></ul>
</li></ul>
<p>
<ul>
<li>a 2-byte field, in network byte order, containing a Linux ARPHRD_ value for the link layer device type;</li><li>a 2-byte field, in network byte order, containing the length of the link layer address of the sender of the packet (which could be 0);</li><li>an 8-byte field containing that number of bytes of the link layer header (if there are more than 8 bytes, only the first 8 are present);</li><li>2-byte field containing an Ethernet protocol type, in network byte order, or containing 1 for Novell 802.3 frames without an 802.2 LLC header or 4 for frames beginning with an 802.2 LLC header.</li></ul>
<p>
DLT_LTALK: Apple LocalTalk; the packet begins with an AppleTalk LLAP header.<ul>
<li>DLT_PFLOG: OpenBSD pflog; the link layer header contains, in order:<ul>
<li>a 4-byte PF_ value, in network byte order;</li><li>a 16-character interface name;</li><li>a 2-byte rule number, in network byte order;</li><li>a 2-byte reason code, in network byte order, which is one of:<ol>
<li>match</li><li>bad offset</li><li>fragment</li><li>short</li><li>normalize</li><li>memory -a 2-byte action code, in network byte order, which is one of:</li><li>passed</li><li>dropped</li><li>scrubbed</li></ol>
</li><li>a 2-byte direction, in network byte order, which is one of:<ol>
<li>incoming or outgoing</li><li>incoming</li><li>outgoing</li></ol>
</li></ul>
</li><li>DLT_PRISM_HEADER: Prism monitor mode information followed by an 802.11 header.</li><li>DLT_IP_OVER_FC: RFC 2625 IP-over-Fibre Channel, with the link-layer header being the Network_Header as described in that RFC.</li><li>DLT_SUNATM: SunATM devices; the link layer header contains, in order:<ul>
<li>a 1-byte flag field, containing a direction flag in the uppermost bit, which is set for packets transmitted by the machine and clear for packets received by the machine, and a 4-byte traffic type in the low-order 4 bits, which is one of:<ol>
<li>raw traffic</li><li>LANE traffic</li><li>LLC-encapsulated traffic</li><li>MARS traffic</li><li>IFMP traffic</li><li>ILMI traffic</li><li>Q.2931 traffic</li></ol>
</li><li>a 1-byte VPI value;</li><li>a 2-byte VCI field, in network byte order.</li></ul>
</li><li>DLT_IEEE802_11_RADIO: link-layer information followed by an 802.11 header - see <a href="http://www.shaftnet.org/~pizza/software/capturefrm.txt">http://www.shaftnet.org/~pizza/software/capturefrm.txt</a> for a description of the link-layer information.</li><li>DLT_ARCNET_LINUX: ARCNET, with no exception frames, reassembled packets rather than raw frames, and an extra 16-bit offset field between the destination host and type bytes.</li><li>DLT_LINUX_IRDA: Linux-IrDA packets, with a DLT_LINUX_SLL header followed by the IrLAP header.</li></ul>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga24">pcap_list_datalinks()</a>, <a class="el" href="group__wpcapfunc.html#ga25">pcap_set_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga26">pcap_datalink_name_to_val()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga26" doxytag="funcs/pcap.h::pcap_datalink_name_to_val" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_datalink_name_to_val           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding data link type value. The translation is case-insensitive. -1 is returned on failure. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga28" doxytag="funcs/pcap.h::pcap_datalink_val_to_description" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* pcap_datalink_val_to_description           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dlt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translates a data link type value to a short description of that data link type. NULL is returned on failure. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga27" doxytag="funcs/pcap.h::pcap_datalink_val_to_name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* pcap_datalink_val_to_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dlt</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Translates a data link type value to the corresponding data link type name. NULL is returned on failure. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="funcs/pcap.h::pcap_dispatch" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_dispatch           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Collect a group of packets. 
<p>
<a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> is used to collect and process packets. cnt specifies the maximum number of packets to process before returning. This is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than cnt packets may be processed. A cnt of -1 processes all the packets received in one buffer when reading a live capture, or all the packets in the file when reading a ``savefile''. callback specifies a routine to be called with three arguments: a u_char pointer which is passed in from <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>, a const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> pointer, and a const u_char pointer to the first caplen (as given in the struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> a pointer to which is passed to the callback routine) bytes of data from the packet (which won't necessarily be the entire packet; to capture the entire packet, you will have to provide a value for snaplen in your call to <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> that is sufficiently large to get all of the packet's data - a value of 65535 should be sufficient on most if not all networks).<p>
The number of packets read is returned. 0 is returned if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a ``savefile.'' A return of -1 indicates an error in which case <a class="el" href="group__wpcapfunc.html#ga35">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> may be used to display the error text. A return of -2 indicates that the loop terminated due to a call to <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a> before any packets were processed. If your application uses <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a>, make sure that you explicitly check for -1 and -2, rather than just checking for a return value &lt; 0.<p>
<dl compact><dt><b>Note:</b></dt><dd>when reading a live capture, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> will not necessarily return when the read times out; on some platforms, the read timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the read timeout should NOT be used in, for example, an interactive application, to allow the packet capture loop to ``poll'' for user input periodically, as there's no guarantee that <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> will return after the timeout expires.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="funcs/pcap.h::pcap_dump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_dump           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>sp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save a packet to disk. 
<p>
<a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> outputs a packet to the "savefile" opened with <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>. Note that its calling arguments are suitable for use with <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>. If called directly, the user parameter is of type pcap_dumper_t as returned by <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga42">pcap_dump_close()</a>, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga42" doxytag="funcs/pcap.h::pcap_dump_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_dump_close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes a savefile. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga40" doxytag="funcs/pcap.h::pcap_dump_file" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> FILE* pcap_dump_file           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the standard I/O stream of the 'savefile' opened by <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga41" doxytag="funcs/pcap.h::pcap_dump_flush" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_dump_flush           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flushes the output buffer to the ``savefile,'' so that any packets written with <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> but not yet written to the ``savefile'' will be written. -1 is returned on error, 0 on success. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="funcs/pcap.h::pcap_dump_ftell" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long pcap_dump_ftell           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the file position for a "savefile". 
<p>
<a class="el" href="group__wpcapfunc.html#ga18">pcap_dump_ftell()</a> returns the current file position for the "savefile", representing the number of bytes written by <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a> and <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> . -1 is returned on error.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="funcs/pcap.h::pcap_dump_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#ga3">pcap_dumper_t</a>* pcap_dump_open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fname</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a file to write packets. 
<p>
<a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a> is called to open a "savefile" for writing. The name "-" in a synonym for stdout. NULL is returned on failure. p is a pcap struct as returned by <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a> or <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>. fname specifies the name of the file to open. Alternatively, you may call pcap_dump_fopen() to write data to an existing open stream fp. Note that on Windows, that stream should be opened in binary mode. If NULL is returned, <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> can be used to get the error text.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga42">pcap_dump_close()</a>, <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga33" doxytag="funcs/pcap.h::pcap_file" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> FILE* pcap_file           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the standard stream of an offline capture. 
<p>
<a class="el" href="group__wpcapfunc.html#ga33">pcap_file()</a> returns the standard I/O stream of the "savefile", if a "savefile" was opened with <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, or NULL, if a network device was opened with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>. <p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Due to incompatibilities between the C Runtime (CRT) used to compile WinPcap and the one used by WinPcap-based applications, this function may return an invalid FILE pointer, i.e. a descriptor that causes all the standard I/O stream functions (ftell, fseek, fclose...) to fail. The function is still available for backwards binary compatibility, only. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="funcs/pcap.h::pcap_findalldevs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_findalldevs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structpcap__if.html">pcap_if_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>alldevsp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>that there may be network devices that cannot be opened with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> by the process calling <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, because, for example, that process might not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) alldevsp is set to point to the first element of the list; each element of the list is of type <a class="el" href="group__wpcap__def.html#ga4">pcap_if_t</a>,</dd></dl>
-1 is returned on failure, in which case errbuf is filled in with an appropriate error message; 0 is returned on success.<p>
<dl compact><dt><b>See also:</b></dt><dd>struct <a class="el" href="structpcap__if.html">pcap_if</a>, <a class="el" href="group__wpcapfunc.html#ga8">pcap_freealldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga9">pcap_lookupdev()</a>, <a class="el" href="group__wpcapfunc.html#ga10">pcap_lookupnet()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga55" doxytag="funcs/pcap.h::pcap_findalldevs_ex" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_findalldevs_ex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>auth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structpcap__if.html">pcap_if_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>alldevs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>. 
<p>
This function is a superset of the old 'pcap_findalldevs()', which is obsolete, and which allows listing only the devices present on the local machine. Vice versa, <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> allows listing the devices present on a remote machine as well. Additionally, it can list all the pcap files available into a given folder. Moreover, <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> is platform independent, since it relies on the standard <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a> to get addresses on the local machine.<p>
In case the function has to list the interfaces on a remote machine, it opens a new control connection toward that machine, it retrieves the interfaces, and it drops the connection. However, if this function detects that the remote machine is in 'active' mode, the connection is not dropped and the existing socket is used.<p>
The 'source' is a parameter that tells the function where the lookup has to be done and it uses the same syntax of the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>.<p>
Differently from the <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, the interface names (pointed by the alldevs-&gt;name and the other ones in the linked list) are already ready to be used in the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> call. Vice versa, the output that comes from <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a> must be formatted with the new <a class="el" href="group__wpcapfunc.html#ga56">pcap_createsrcstr()</a> before passing the source identifier to the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>source:</em>&nbsp;</td><td>a char* buffer that keeps the 'source localtion', according to the new WinPcap syntax. This source will be examined looking for adapters (local or remote) (e.g. source can be 'rpcap://' for local adapters or 'rpcap://host:port' for adapters on a remote host) or pcap files (e.g. source can be 'file://c:/myfolder/').<br>
 The strings that must be prepended to the 'source' in order to define if we want local/remote adapters or files is defined in the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.</td></tr>
    <tr><td></td><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host. This parameter is not meaningful in case of a query to the local host: in that case it can be NULL.</td></tr>
    <tr><td></td><td valign=top><em>alldevs:</em>&nbsp;</td><td>a 'struct pcap_if_t' pointer, which will be properly allocated inside this function. When the function returns, it is set to point to the first element of the interface list; each element of the list is of type 'struct pcap_if_t'.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The list of the devices is returned in the 'alldevs' variable. When the function returns correctly, 'alldevs' cannot be NULL. In other words, this function returns '-1' also in case the system does not have any interface to list.</dd></dl>
The error message is returned in the 'errbuf' variable. An error could be due to several reasons:<ul>
<li>libpcap/WinPcap was not installed on the local/remote host</li><li>the user does not have enough privileges to list the devices / files</li><li>a network problem</li><li>the RPCAP version negotiation failed</li><li>other errors (not enough memory and others).</li></ul>
<p>
<dl compact><dt><b>Warning:</b></dt><dd>There may be network devices that cannot be opened with <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> by the process calling <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, because, for example, that process might not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.<p>
The interface list must be deallocated manually by using the <a class="el" href="group__wpcapfunc.html#ga8">pcap_freealldevs()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="funcs/pcap.h::pcap_freealldevs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_freealldevs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structpcap__if.html">pcap_if_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>alldevsp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free an interface list returned by <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>. 
<p>
<a class="el" href="group__wpcapfunc.html#ga8">pcap_freealldevs()</a> is used to free a list allocated by <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="funcs/pcap.h::pcap_freecode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_freecode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct bpf_program *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a filter. 
<p>
<a class="el" href="group__wpcapfunc.html#ga22">pcap_freecode()</a> is used to free up allocated memory pointed to by a bpf_program struct generated by <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a> when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to <a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga36" doxytag="funcs/pcap.h::pcap_geterr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* pcap_geterr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the error text pertaining to the last pcap library error. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>the pointer Return will no longer point to a valid error message string after the pcap_t passed to it is closed; you must use or copy the string before closing the pcap_t.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga35">pcap_perror()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga50" doxytag="funcs/pcap.h::pcap_getevent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HANDLE pcap_getevent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the handle of the event associated with the interface p. 
<p>
This event can be passed to functions like WaitForSingleObject() or WaitForMultipleObjects() to wait until the driver's buffer contains some data without performing a read.<p>
We disourage the use of this function because it is not portable.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="funcs/pcap.h::pcap_getnonblock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_getnonblock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the "non-blocking" state of an interface. 
<p>
<a class="el" href="group__wpcapfunc.html#ga6">pcap_getnonblock()</a> returns the current "non-blocking" state of the capture descriptor; it always returns 0 on "savefiles". If there is an error, -1 is returned and errbuf is filled in with an appropriate error message.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga5">pcap_setnonblock()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga30" doxytag="funcs/pcap.h::pcap_is_swapped" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_is_swapped           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
returns true if the current savefile uses a different byte order than the current system. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga38" doxytag="funcs/pcap.h::pcap_lib_version" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* pcap_lib_version           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="funcs/pcap.h::pcap_list_datalinks" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_list_datalinks           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>dlt_buf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
list datalinks 
<p>
<a class="el" href="group__wpcapfunc.html#ga24">pcap_list_datalinks()</a> is used to get a list of the supported data link types of the interface associated with the pcap descriptor. <a class="el" href="group__wpcapfunc.html#ga24">pcap_list_datalinks()</a> allocates an array to hold the list and sets *dlt_buf. The caller is responsible for freeing the array. -1 is returned on failure; otherwise, the number of data link types in the array is returned.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga23">pcap_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga25">pcap_set_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga26">pcap_datalink_name_to_val()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga44" doxytag="funcs/pcap.h::pcap_live_dump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_live_dump           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxpacks</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save a capture to file. 
<p>
<a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> dumps the network traffic from an interface to a file. Using this function the dump is performed at kernel level, therefore it is more efficient than using <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a>.<p>
The parameters of this function are an interface descriptor (obtained with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>), a string with the name of the dump file, the maximum size of the file (in bytes) and the maximum number of packets that the file will contain. Setting maxsize or maxpacks to 0 means no limit. When maxsize or maxpacks are reached, the dump ends.<p>
<a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> is non-blocking, threfore Return immediately. <a class="el" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended()</a> can be used to check the status of the dump process or to wait until it is finished. <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a> can instead be used to end the dump process.<p>
Note that when one of the two limits is reached, the dump is stopped, but the file remains opened. In order to correctly flush the data and put the file in a consistent state, the adapter must be closed with <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a>, <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga45" doxytag="funcs/pcap.h::pcap_live_dump_ended" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_live_dump_ended           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>sync</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the status of the kernel dump process, i.e. tells if one of the limits defined with <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> has been reached. 
<p>
<a class="el" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended()</a> informs the user about the limits that were set with a previous call to <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> on the interface pointed by p: if the return value is nonzero, one of the limits has been reched and the dump process is currently stopped.<p>
If sync is nonzero, the function blocks until the dump is finished, otherwise Return immediately.<p>
<dl compact><dt><b>Warning:</b></dt><dd>if the dump process has no limits (i.e. if the maxsize and maxpacks arguments of <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> were both 0), the dump process will never stop, therefore setting sync to TRUE will block the application on this call forever.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="funcs/pcap.h::pcap_lookupdev" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* pcap_lookupdev           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>errbuf</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the first valid device in the system. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs</a>() or <a class="el" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>() instead. </dd></dl>
<a class="el" href="group__wpcapfunc.html#ga9">pcap_lookupdev()</a> returns a pointer to a network device suitable for use with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> and <a class="el" href="group__wpcapfunc.html#ga10">pcap_lookupnet()</a>. If there is an error, NULL is returned and errbuf is filled in with an appropriate error message.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="funcs/pcap.h::pcap_lookupnet" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_lookupnet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>netp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcap__def.html#ga1">bpf_u_int32</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>maskp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the subnet and netmask of an interface. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs</a>() or <a class="el" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>() instead. </dd></dl>
<a class="el" href="group__wpcapfunc.html#ga10">pcap_lookupnet()</a> is used to determine the network number and mask associated with the network device device. Both netp and maskp are bpf_u_int32 pointers. A return of -1 indicates an error in which case errbuf is filled in with an appropriate error message.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="funcs/pcap.h::pcap_loop" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_loop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>user</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Collect a group of packets. 
<p>
<a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> is similar to <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> except it keeps reading packets until cnt packets are processed or an error occurs. It does not return when live read timeouts occur. Rather, specifying a non-zero read timeout to <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> and then calling <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> allows the reception and processing of any packets that arrive when the timeout occurs. A negative cnt causes <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> to loop forever (or at least until an error occurs). -1 is returned on an error; 0 is returned if cnt is exhausted; -2 is returned if the loop terminated due to a call to <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a> before any packets were processed. If your application uses <a class="el" href="group__wpcapfunc.html#ga15">pcap_breakloop()</a>, make sure that you explicitly check for -1 and -2, rather than just checking for a return value &lt; 0.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga31" doxytag="funcs/pcap.h::pcap_major_version" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_major_version           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the major version number of the pcap library used to write the savefile. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga32">pcap_minor_version()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga32" doxytag="funcs/pcap.h::pcap_minor_version" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_minor_version           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return the minor version number of the pcap library used to write the savefile. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga31">pcap_major_version()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="funcs/pcap.h::pcap_next" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_char* pcap_next           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the next available packet. 
<p>
<a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a> reads the next packet (by calling <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> with a cnt of 1) and returns a u_char pointer to the data in that packet. (The <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> struct for that packet is not supplied.) NULL is returned if an error occured, or if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a ``savefile.'' Unfortunately, there is no way to determine whether an error occured or not. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="funcs/pcap.h::pcap_next_ex" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_next_ex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const u_char **&nbsp;</td>
          <td class="mdname" nowrap> <em>pkt_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a packet from an interface or from an offline capture. 
<p>
This function is used to retrieve the next available packet, bypassing the callback method traditionally provided by libpcap.<p>
pcap_next_ex fills the pkt_header and pkt_data parameters (see <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler()</a>) with the pointers to the header and to the data of the next captured packet.<p>
The return value can be:<ul>
<li>1 if the packet has been read without problems</li><li>0 if the timeout set with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> has elapsed. In this case pkt_header and pkt_data don't point to a valid packet</li><li>-1 if an error occurred</li><li>-2 if EOF was reached reading from an offline capture</li></ul>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga43" doxytag="funcs/pcap.h::pcap_offline_filter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool pcap_offline_filter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct bpf_program *&nbsp;</td>
          <td class="mdname" nowrap> <em>prog</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pkt_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns if a given filter applies to an offline packet. 
<p>
This function is used to apply a filter to a packet that is currently in memory. This process does not need to open an adapter; we need just to create the proper filter (by settings parameters like the snapshot length, or the link-layer type) by means of the <a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a>.<p>
The current API of libpcap does not allow to receive a packet and to filter the packet after it has been received. However, this can be useful in case you want to filter packets in the application, instead of into the receiving process. This function allows you to do the job.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>prog:</em>&nbsp;</td><td>bpf program (created with the <a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> ) </td></tr>
    <tr><td></td><td valign=top><em>header:</em>&nbsp;</td><td>header of the packet that has to be filtered </td></tr>
    <tr><td></td><td valign=top><em>pkt_data:</em>&nbsp;</td><td>buffer containing the packet, in network-byte order.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the length of the bytes that are currently available into the packet if the packet satisfies the filter, 0 otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga58" doxytag="funcs/pcap.h::pcap_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#ga2">pcap_t</a>* pcap_open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>snaplen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>read_timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>auth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a generic source in order to capture / send (WinPcap only) traffic. 
<p>
The <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> replaces all the pcap_open_xxx() functions with a single call.<p>
This function hides the differences between the different pcap_open_xxx() functions so that the programmer does not have to manage different opening function. In this way, the 'true' open function is decided according to the source type, which is included into the source string (in the form of source prefix).<p>
This function can rely on the <a class="el" href="group__wpcapfunc.html#ga56">pcap_createsrcstr()</a> to create the string that keeps the capture device according to the new syntax, and the <a class="el" href="group__wpcapfunc.html#ga57">pcap_parsesrcstr()</a> for the other way round.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>source:</em>&nbsp;</td><td>zero-terminated string containing the source name to open. The source name has to include the format prefix according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax</a> and it cannot be NULL.<br>
 On on Linux systems with 2.2 or later kernels, a device argument of "any" (i.e. rpcap://any) can be used to capture packets from all interfaces. <br>
 In order to makes the source syntax easier, please remember that:<ul>
<li>the adapters returned by the <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> can be used immediately by the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a></li><li>in case the user wants to pass its own source string to the <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>, the <a class="el" href="group__wpcapfunc.html#ga56">pcap_createsrcstr()</a> helps in creating the correct source identifier.</li></ul>
</td></tr>
    <tr><td></td><td valign=top><em>snaplen:</em>&nbsp;</td><td>length of the packet that has to be retained. For each packet received by the filter, only the first 'snaplen' bytes are stored in the buffer and passed to the user application. For instance, snaplen equal to 100 means that only the first 100 bytes of each packet are stored.</td></tr>
    <tr><td></td><td valign=top><em>flags:</em>&nbsp;</td><td>keeps several flags that can be needed for capturing packets. The allowed flags are defined in the <a class="el" href="group__remote__open__flags.html">pcap_open() flags </a>.</td></tr>
    <tr><td></td><td valign=top><em>read_timeout:</em>&nbsp;</td><td>read timeout in milliseconds. The read timeout is used to arrange that the read not necessarily return immediately when a packet is seen, but that it waits for some amount of time to allow more packets to arrive and to read multiple packets from the OS kernel in one operation. Not all platforms support a read timeout; on platforms that don't, the read timeout is ignored.</td></tr>
    <tr><td></td><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a 'struct pcap_rmtauth' that keeps the information required to authenticate the user on a remote machine. In case this is not a remote capture, this pointer can be set to NULL.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer which will contain the error in case this function fails. The <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> and findalldevs() are the only two functions which have this parameter, since they do not have (yet) a pointer to a pcap_t structure, which reserves space for the error string. Since these functions do not have (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of errors), they need an explicit 'errbuf' variable. 'errbuf' may also be set to warning text when <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> succeds; to detect this case the caller should store a zero-length string in 'errbuf' before calling <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> and display the warning to the user if 'errbuf' is no longer a zero-length string.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a 'pcap_t' which can be used as a parameter to the following calls (<a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a> and so on) and that specifies an opened WinPcap session. In case of problems, it returns NULL and the 'errbuf' variable keeps the error message.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>The source cannot be larger than PCAP_BUF_SIZE.<p>
The following formats are not allowed as 'source' strings:<ul>
<li>rpcap:// [to open the first local adapter]</li><li>rpcap://hostname/ [to open the first remote adapter] </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="funcs/pcap.h::pcap_open_dead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#ga2">pcap_t</a>* pcap_open_dead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>linktype</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>snaplen</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a pcap_t structure without starting a capture. 
<p>
<a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead()</a> is used for creating a pcap_t structure to use when calling the other functions in libpcap. It is typically used when just using libpcap for compiling BPF code.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="funcs/pcap.h::pcap_open_live" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#ga2">pcap_t</a>* pcap_open_live           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>snaplen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>promisc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_ms</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>ebuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a live capture from the network. 
<p>
<a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> is used to obtain a packet capture descriptor to look at packets on the network. device is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a device argument of "any" or NULL can be used to capture packets from all interfaces. snaplen specifies the maximum number of bytes to capture. If this value is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data. A value of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet. promisc specifies if the interface is to be put into promiscuous mode. (Note that even if this parameter is false, the interface could well be in promiscuous mode for some other reason.) For now, this doesn't work on the "any" device; if an argument of "any" or NULL is supplied, the promisc flag is ignored. to_ms specifies the read timeout in milliseconds. The read timeout is used to arrange that the read not necessarily return immediately when a packet is seen, but that it wait for some amount of time to allow more packets to arrive and to read multiple packets from the OS kernel in one operation. Not all platforms support a read timeout; on platforms that don't, the read timeout is ignored. A zero value for to_ms, on platforms that support a read timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. errbuf is used to return error or warning text. It will be set to error text when <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> fails and returns NULL. errbuf may also be set to warning text when <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> succeds; to detect this case the caller should store a zero-length string in errbuf before calling <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> and display the warning to the user if errbuf is no longer a zero-length string.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga2">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="funcs/pcap.h::pcap_open_offline" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__wpcap__def.html#ga2">pcap_t</a>* pcap_open_offline           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a savefile in the tcpdump/libpcap format to read packets. 
<p>
<a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a> is called to open a "savefile" for reading. fname specifies the name of the file to open. The file has the same format as those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data from an existing open stream fp. Note that on Windows, that stream should be opened in binary mode. errbuf is used to return error text and is only set when <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a> or pcap_fopen_offline() fails and returns NULL.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga7">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga39">pcap_close()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga57" doxytag="funcs/pcap.h::pcap_parsesrcstr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_parsesrcstr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Parse the source string and returns the pieces in which the source can be split. 
<p>
This call is the other way round of <a class="el" href="group__wpcapfunc.html#ga56">pcap_createsrcstr()</a>. It accepts a null-terminated string and it returns the parameters related to the source. This includes:<ul>
<li>the type of the source (file, winpcap on a remote adapter, winpcap on local adapter), which is determined by the source prefix (PCAP_SRC_IF_STRING and so on)</li><li>the host on which the capture has to be started (only for remote captures)</li><li>the 'raw' name of the source (file name, name of the remote adapter, name of the local adapter), without the source prefix. The string returned does not include the type of the source itself (i.e. the string returned does not include "file://" or rpcap:// or such).</li></ul>
<p>
The user can omit some parameters in case it is not interested in them.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>source:</em>&nbsp;</td><td>a null-terminated string containing the WinPcap source. This source starts with an identifier according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.</td></tr>
    <tr><td></td><td valign=top><em>type:</em>&nbsp;</td><td>pointer to an integer, which is used to return the code corrisponding to the selected source. The code will be one defined in the <a class="el" href="group__remote__source__ID.html">Source identification Codes </a>.<br>
 In case the source string does not exists (i.e. 'source == NULL') or it is empty ('*source == NULL'), it returns PCAP_SRC_IF_LOCAL (i.e. you are ready to call <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> ). This behavior is kept only for compatibility with older applications (e.g. tcpdump); therefore we suggest to move to the new syntax for sources.<br>
 This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td></td><td valign=top><em>host:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the host name on which the capture has to be started. This value is meaningful only in case of remote capture; otherwise, the returned string will be empty (""). This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td></td><td valign=top><em>port:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the port that has to be used by the RPCAP protocol to contact the other host. This value is meaningful only in case of remote capture and if the user wants to use a non-standard port; otherwise, the returned string will be empty (""). In case of remote capture, an emply string means "use the standard RPCAP port". This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td></td><td valign=top><em>name:</em>&nbsp;</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the source name, without the source prefix. If the name does not exist (for example because source contains 'rpcap://' that means 'default local adapter'), it returns NULL. This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). This parameter can be NULL in case the user is not interested in that.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The requested values (host name, network port, type of the source) are returned into the proper variables passed by reference. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga35" doxytag="funcs/pcap.h::pcap_perror" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_perror           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>prefix</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
print the text of the last pcap library error on stderr, prefixed by prefix. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga60" doxytag="funcs/pcap.h::pcap_remoteact_accept" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SOCKET pcap_remoteact_accept           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>connectinghost</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>auth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Block until a network connection is accepted (active mode only). 
<p>
This function has been defined to allow the client dealing with the 'active mode'. In other words, in the 'active mode' the server opens the connection toward the client, so that the client has to open a socket in order to wait for connections. When a new connection is accepted, the RPCAP protocol starts as usual; the only difference is that the connection is initiated by the server.<p>
This function accepts only ONE connection, then it closes the waiting socket. This means that if some error occurs, the application has to call it again in order to accept another connection.<p>
This function returns when a new connection (coming from a valid host 'connectinghost') is accepted; it returns error otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>address:</em>&nbsp;</td><td>a string that keeps the network address we have to bind to; usually it is NULL (it means 'bind on all local addresses').</td></tr>
    <tr><td></td><td valign=top><em>port:</em>&nbsp;</td><td>a string that keeps the network port on which we have to bind to; usually it is NULL (it means 'bind on the predefined port', i.e. RPCAP_DEFAULT_NETPORT_ACTIVE).</td></tr>
    <tr><td></td><td valign=top><em>hostlist:</em>&nbsp;</td><td>a string that keeps the host name of the host from whom we are expecting a connection; it can be NULL (it means 'accept connection from everyone'). Host names are separated by a whatever character in the RPCAP_HOSTLIST_SEP list.</td></tr>
    <tr><td></td><td valign=top><em>connectinghost:</em>&nbsp;</td><td>a user-allocated buffer that will contain the name of the host is trying to connect to us. This variable must be at least RPCAP_HOSTLIST_SIZE bytes..</td></tr>
    <tr><td></td><td valign=top><em>auth:</em>&nbsp;</td><td>a pointer to a <a class="el" href="structpcap__rmtauth.html">pcap_rmtauth</a> structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The SOCKET identifier of the new control connection if everything is fine, a negative number if some errors occurred. The error message is returned into the errbuf variable. In case it returns '-1', this means 'everything is fine', but the host cannot be admitted. In case it returns '-2', in means 'unrecoverable error' (for example it is not able to bind the socket, or something like that). In case it returns '-3', it means 'authentication failed'. The authentication check is performed only if the connecting host is among the ones that are allowed to connect to this host.</dd></dl>
The host that is connecting to us is returned into the hostlist variable, which ust be allocated by the user. This variable contains the host name both in case the host is allowed, and in case the connection is refused.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Although this function returns the socket established by the new control connection, this value should not be used. This value will be stored into some libpcap internal variables and it will be managed automatically by the library. In other words, all the following calls to findalldevs() and <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a> will check if the host is among one that already has a control connection in place; if so, that one will be used.<p>
This function has several problems if used inside a thread, which is stopped when this call is blocked into the accept(). In this case, the socket on which we accept connections is not freed (thread termination is a very dirty job), so that we are no longer able to accept other connections until the program (i.e. the process) stops. In order to solve the problem, call the <a class="el" href="group__wpcapfunc.html#ga62">pcap_remoteact_cleanup()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga62" doxytag="funcs/pcap.h::pcap_remoteact_cleanup" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_remoteact_cleanup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clean the socket that is currently used in waiting active connections. 
<p>
This function does a very dirty job. The fact is that is the waiting socket is not freed if the pcap_remoteaccept() is killed inside a new thread. This function is able to clean the socket in order to allow the next calls to <a class="el" href="group__wpcapfunc.html#ga60">pcap_remoteact_accept()</a> to work.<p>
This function is useful *only* if you launch <a class="el" href="group__wpcapfunc.html#ga60">pcap_remoteact_accept()</a> inside a new thread, and you stops (not very gracefully) the thread (for example because the user changed idea, and it does no longer want to wait for an active connection). So, basically, the flow should be the following:<ul>
<li>launch a new thread</li><li>call the pcap_remoteact_accept</li><li>if this new thread is killed, call <a class="el" href="group__wpcapfunc.html#ga62">pcap_remoteact_cleanup()</a>.</li></ul>
<p>
This function has no effects in other cases.<p>
<dl compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga61" doxytag="funcs/pcap.h::pcap_remoteact_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_remoteact_close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Drop an active connection (active mode only). 
<p>
This function has been defined to allow the client dealing with the 'active mode'. This function closes an active connection that is still in place and it purges the host name from the 'activeHost' list. From this point on, the client will not have any connection with that host in place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>host:</em>&nbsp;</td><td>a string that keeps the host name of the host for which we want to close the active connection.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga63" doxytag="funcs/pcap.h::pcap_remoteact_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_remoteact_list           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>hostlist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>sep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the hostname of the host that have an active connection with us (active mode only). 
<p>
This function has been defined to allow the client dealing with the 'active mode'. This function returns the list of hosts that are currently having an active connection with us. This function is useful in order to delete an active connection that is still in place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>hostlist:</em>&nbsp;</td><td>a user-allocated string that will keep the list of host that are currently connected with us.</td></tr>
    <tr><td></td><td valign=top><em>sep:</em>&nbsp;</td><td>the character that has to be sued as a separator between the hosts (',' for example).</td></tr>
    <tr><td></td><td valign=top><em>size:</em>&nbsp;</td><td>size of the hostlist buffer.</td></tr>
    <tr><td></td><td valign=top><em>errbuf:</em>&nbsp;</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="funcs/pcap.h::pcap_sendpacket" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_sendpacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a raw packet. 
<p>
This function allows to send a raw packet to the network. p is the interface that will be used to send the packet, buf contains the data of the packet to send (including the various protocol headers), size is the dimension of the buffer pointed by buf, i.e. the size of the packet to send. The MAC CRC doesn't need to be included, because it is transparently calculated and added by the network interface driver. The return value is 0 if the packet is succesfully sent, -1 otherwise.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga51" doxytag="funcs/pcap.h::pcap_sendqueue_alloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structpcap__send__queue.html">pcap_send_queue</a>* pcap_sendqueue_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>memsize</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a send queue. 
<p>
This function allocates a send queue, i.e. a buffer containing a set of raw packets that will be transimtted on the network with <a class="el" href="group__wpcapfunc.html#ga54">pcap_sendqueue_transmit()</a>.<p>
memsize is the size, in bytes, of the queue, therefore it determines the maximum amount of data that the queue will contain.<p>
Use <a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a> to insert packets in the queue.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#ga54">pcap_sendqueue_transmit()</a>, <a class="el" href="group__wpcapfunc.html#ga52">pcap_sendqueue_destroy()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga52" doxytag="funcs/pcap.h::pcap_sendqueue_destroy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pcap_sendqueue_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>queue</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a send queue. 
<p>
Deletes a send queue and frees all the memory associated with it.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga51">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#ga54">pcap_sendqueue_transmit()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga53" doxytag="funcs/pcap.h::pcap_sendqueue_queue" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_sendqueue_queue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const u_char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pkt_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a packet to a send queue. 
<p>
<a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a> adds a packet at the end of the send queue pointed by the queue parameter. pkt_header points to a <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> structure with the timestamp and the length of the packet, pkt_data points to a buffer with the data of the packet.<p>
The <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> structure is the same used by WinPcap and libpcap to store the packets in a file, therefore sending a capture file is straightforward. 'Raw packet' means that the sending application will have to include the protocol headers, since every packet is sent to the network 'as is'. The CRC of the packets needs not to be calculated, because it will be transparently added by the network interface.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga51">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#ga54">pcap_sendqueue_transmit()</a>, <a class="el" href="group__wpcapfunc.html#ga52">pcap_sendqueue_destroy()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga54" doxytag="funcs/pcap.h::pcap_sendqueue_transmit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int pcap_sendqueue_transmit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>sync</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a queue of raw packets to the network. 
<p>
This function transmits the content of a queue to the wire. p is a pointer to the adapter on which the packets will be sent, queue points to a <a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> structure containing the packets to send (see <a class="el" href="group__wpcapfunc.html#ga51">pcap_sendqueue_alloc()</a> and <a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a>), sync determines if the send operation must be synchronized: if it is non-zero, the packets are sent respecting the timestamps, otherwise they are sent as fast as possible.<p>
The return value is the amount of bytes actually sent. If it is smaller than the size parameter, an error occurred during the send. The error can be caused by a driver/adapter problem or by an inconsistent/bogus send queue.<p>
<dl compact><dt><b>Note:</b></dt><dd>Using this function is more efficient than issuing a series of <a class="el" href="group__wpcapfunc.html#ga16">pcap_sendpacket()</a>, because the packets are buffered in the kernel driver, so the number of context switches is reduced. Therefore, expect a better throughput when using pcap_sendqueue_transmit.<p>
When Sync is set to TRUE, the packets are synchronized in the kernel with a high precision timestamp. This requires a non-negligible amount of CPU, but allows normally to send the packets with a precision of some microseconds (depending on the accuracy of the performance counter of the machine). Such a precision cannot be reached sending the packets with <a class="el" href="group__wpcapfunc.html#ga16">pcap_sendpacket()</a>.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga51">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#ga53">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#ga52">pcap_sendqueue_destroy()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="funcs/pcap.h::pcap_set_datalink" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_set_datalink           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dlt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga47" doxytag="funcs/pcap.h::pcap_setbuff" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setbuff           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dim</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the size of the kernel buffer associated with an adapter. 
<p>
<em>dim</em> specifies the size of the buffer in bytes. The return value is 0 when the call succeeds, -1 otherwise. If an old buffer was already created with a previous call to <a class="el" href="group__wpcapfunc.html#ga47">pcap_setbuff()</a>, it is deleted and its content is discarded. <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> creates a 1 MByte buffer by default.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="funcs/pcap.h::pcap_setfilter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setfilter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct bpf_program *&nbsp;</td>
          <td class="mdname" nowrap> <em>fp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate a filter to a capture. 
<p>
<a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a> is used to specify a filter program. fp is a pointer to a bpf_program struct, usually the result of a call to <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>. -1 is returned on failure, in which case <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> may be used to display the error text; 0 is returned on success.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga49" doxytag="funcs/pcap.h::pcap_setmintocopy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setmintocopy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the minumum amount of data received by the kernel in a single call. 
<p>
<a class="el" href="group__wpcapfunc.html#ga49">pcap_setmintocopy()</a> changes the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires). If the value of <em>size</em> is large, the kernel is forced to wait the arrival of several packets before copying the data to the user. This guarantees a low number of system calls, i.e. low processor usage, and is a good setting for applications like packet-sniffers and protocol analyzers. Vice versa, in presence of a small value for this variable, the kernel will copy the packets as soon as the application is ready to receive them. This is useful for real time applications that need the best responsiveness from the kernel.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga48" doxytag="funcs/pcap.h::pcap_setmode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setmode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the working mode of the interface p to mode. 
<p>
Valid values for mode are MODE_CAPT (default capture mode) and MODE_STAT (statistical mode). See the tutorial "\ref wpcap_tut9" for details about statistical mode.     </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="funcs/pcap.h::pcap_setnonblock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_setnonblock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nonblock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>errbuf</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Switch between blocking and nonblocking mode. 
<p>
<a class="el" href="group__wpcapfunc.html#ga5">pcap_setnonblock()</a> puts a capture descriptor, opened with <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, into "non-blocking" mode, or takes it out of "non-blocking" mode, depending on whether the nonblock argument is non-zero or zero. It has no effect on "savefiles". If there is an error, -1 is returned and errbuf is filled in with an appropriate error message; otherwise, 0 is returned. In "non-blocking" mode, an attempt to read from the capture descriptor with <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> and <a class="el" href="group__wpcapfunc.html#ga13">pcap_next()</a> will not work in "non-blocking" mode.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga6">pcap_getnonblock()</a>, <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga59" doxytag="funcs/pcap.h::pcap_setsampling" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpcap__samp.html">pcap_samp</a>* pcap_setsampling           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Define a sampling method for packet capture. 
<p>
This function allows applying a sampling method to the packet capture process. The currently sampling methods (and the way to set them) are described into the struct <a class="el" href="structpcap__samp.html">pcap_samp</a>. In other words, the user must set the appropriate parameters into it; these will be applied as soon as the capture starts.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Sampling parameters <b>cannot</b> be changed when a capture is active. These parameters must be applied <b>before</b> starting the capture. If they are applied when the capture is in progress, the new settings are ignored.<p>
Sampling works only when capturing data on Win32 or reading from a file. It has not been implemented on other platforms. Sampling works on remote machines provided that the probe (i.e. the capturing device) is a Win32 workstation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga29" doxytag="funcs/pcap.h::pcap_snapshot" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_snapshot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the dimension of the packet portion (in bytes) that is delivered to the application. 
<p>
<a class="el" href="group__wpcapfunc.html#ga29">pcap_snapshot()</a> returns the snapshot length specified when pcap_open_live was called.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga19">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga20">pcap_compile_nopcap()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga34" doxytag="funcs/pcap.h::pcap_stats" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcap_stats           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return statistics on current capture. 
<p>
<a class="el" href="group__wpcapfunc.html#ga34">pcap_stats()</a> returns 0 and fills in a <a class="el" href="structpcap__stat.html">pcap_stat</a> struct. The values represent packet statistics from the start of the run to the time of the call. If there is an error or the underlying packet capture doesn't support packet statistics, -1 is returned and the error text can be obtained with <a class="el" href="group__wpcapfunc.html#ga35">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a>. <a class="el" href="group__wpcapfunc.html#ga34">pcap_stats()</a> is supported only on live captures, not on "savefiles"; no statistics are stored in "savefiles", so no statistics are available when reading from a "savefile".<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga46">pcap_stats_ex()</a>, <a class="el" href="group__wpcapfunc.html#ga1">pcap_open_live()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga46" doxytag="funcs/pcap.h::pcap_stats_ex" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpcap__stat.html">pcap_stat</a>* pcap_stats_ex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__wpcap__def.html#ga2">pcap_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>pcap_stat_size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return statistics on current capture. 
<p>
<a class="el" href="group__wpcapfunc.html#ga46">pcap_stats_ex()</a> extends the <a class="el" href="group__wpcapfunc.html#ga34">pcap_stats()</a> allowing to return more statistical parameters than the old call. One of the advantages of this new call is that the <a class="el" href="structpcap__stat.html">pcap_stat</a> structure is not allocated by the user; instead, it is returned back by the system. This allow to extend the <a class="el" href="structpcap__stat.html">pcap_stat</a> structure without affecting backward compatibility on older applications. These will simply check at the values of the members at the beginning of the structure, while only newest applications are able to read new statistical values, which are appended in tail.<p>
To be sure not to read a piece of mamory which has not been allocated by the system, the variable pcap_stat_size will return back the size of the structure <a class="el" href="structpcap__stat.html">pcap_stat</a> allocated by the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>p:</em>&nbsp;</td><td>pointer to the pcap_t currently in use. </td></tr>
    <tr><td></td><td valign=top><em>pcap_stat_size:</em>&nbsp;</td><td>pointer to an integer that will contain (when the function returns back) the size of the structure <a class="el" href="structpcap__stat.html">pcap_stat</a> as it has been allocated by the system.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>: a pointer to a <a class="el" href="structpcap__stat.html">pcap_stat</a> structure, that will contain the statistics related to the current device. The return value is NULL in case of errors, and the error text can be obtained with <a class="el" href="group__wpcapfunc.html#ga35">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a>.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga46">pcap_stats_ex()</a> is supported only on live captures, not on "savefiles"; no statistics are stored in "savefiles", so no statistics are available when reading from a "savefile".</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga34">pcap_stats()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga37" doxytag="funcs/pcap.h::pcap_strerror" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* pcap_strerror           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provided in case strerror() isn't available. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__wpcapfunc.html#ga35">pcap_perror()</a>, <a class="el" href="group__wpcapfunc.html#ga36">pcap_geterr()</a> </dd></dl>
    </td>
  </tr>
</table>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
