<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Handling offline dump files</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Handling offline dump files<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to using WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
In this lession we are going to learn how to handle packet capture to a file (dump to file). WinPcap offers a wide range of functions to save the network traffic to a file and to read the content of dumps -- this lesson will teach how to use all of these functions. We'll see also how to use the kernel dump feature of WinPcap to obtain high-performance dumps (<b>NOTE:</b> At the moment, due to some problems with the new kernel buffer, this feature has been disabled).<p>
The format for dump files is the libpcap one. This format contains the data of the captured packets in binary form and is a standard used by many network tools including WinDump, Ethereal and Snort.<p>
<b>Saving packets to a dump file</b><p>
First of all, let's see how to write packets in libpcap format.<p>
The following example captures the packets from the selected interface and saves them on a file whose name is provided by the user.<p>
<pre><div class="fragment"><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
<a class="code" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *dumpfile;


    
    <span class="comment">/* Check command line */</span>
    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Retrieve the device list on the local machine */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
        
    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
    
    
    <span class="comment">/* Open the device */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,          <span class="comment">// name of the device</span>
                              65536,            <span class="comment">// portion of the packet to capture</span>
                                                <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                              PCAP_OPENFLAG_PROMISCUOUS,    <span class="comment">// promiscuous mode</span>
                              1000,             <span class="comment">// read timeout</span>
                              NULL,             <span class="comment">// authentication on the remote machine</span>
                              errbuf            <span class="comment">// error buffer</span>
                              ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Open the dump file */</span>
    dumpfile = <a class="code" href="group__wpcapfunc.html#ga4">pcap_dump_open</a>(adhandle, argv[1]);

    <span class="keywordflow">if</span>(dumpfile==NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening output file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s... Press Ctrl+C to stop...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
    
    <span class="comment">/* At this point, we no longer need the device list. Free it */</span>
    <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dumpfile);

    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> packet_handler(u_char *dumpfile, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="comment">/* save the packet on the dump file */</span>
    <a class="code" href="group__wpcapfunc.html#ga17">pcap_dump</a>(dumpfile, header, pkt_data);
}
</div></pre><pre><div class="fragment">00001 <span class="preprocessor">#include "pcap.h"</span>
00002 
00003 <span class="comment">/* prototype of the packet handler */</span>
00004 <span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);
00005 
00006 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00007 {
00008 <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
00009 <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
00010 <span class="keywordtype">int</span> inum;
00011 <span class="keywordtype">int</span> i=0;
00012 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
00013 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00014 <a class="code" href="group__wpcap__def.html#ga3">pcap_dumper_t</a> *dumpfile;
00015 
00016 
00017     
00018     <span class="comment">/* Check command line */</span>
00019     <span class="keywordflow">if</span>(argc != 2)
00020     {
00021         printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
00022         <span class="keywordflow">return</span> -1;
00023     }
00024     
00025     <span class="comment">/* Retrieve the device list on the local machine */</span>
00026     <span class="keywordflow">if</span> (<a class="code" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
00027     {
00028         fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
00029         exit(1);
00030     }
00031     
00032     <span class="comment">/* Print the list */</span>
00033     <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
00034     {
00035         printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00036         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
00037             printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00038         <span class="keywordflow">else</span>
00039             printf(<span class="stringliteral">" (No description available)\n"</span>);
00040     }
00041 
00042     <span class="keywordflow">if</span>(i==0)
00043     {
00044         printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
00045         <span class="keywordflow">return</span> -1;
00046     }
00047     
00048     printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
00049     scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
00050     
00051     <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
00052     {
00053         printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
00054         <span class="comment">/* Free the device list */</span>
00055         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00056         <span class="keywordflow">return</span> -1;
00057     }
00058         
00059     <span class="comment">/* Jump to the selected adapter */</span>
00060     <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
00061     
00062     
00063     <span class="comment">/* Open the device */</span>
00064     <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,          <span class="comment">// name of the device</span>
00065                               65536,            <span class="comment">// portion of the packet to capture</span>
00066                                                 <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
00067                               PCAP_OPENFLAG_PROMISCUOUS,    <span class="comment">// promiscuous mode</span>
00068                               1000,             <span class="comment">// read timeout</span>
00069                               NULL,             <span class="comment">// authentication on the remote machine</span>
00070                               errbuf            <span class="comment">// error buffer</span>
00071                               ) ) == NULL)
00072     {
00073         fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00074         <span class="comment">/* Free the device list */</span>
00075         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00076         <span class="keywordflow">return</span> -1;
00077     }
00078 
00079     <span class="comment">/* Open the dump file */</span>
00080     dumpfile = <a class="code" href="group__wpcapfunc.html#ga4">pcap_dump_open</a>(adhandle, argv[1]);
00081 
00082     <span class="keywordflow">if</span>(dumpfile==NULL)
00083     {
00084         fprintf(stderr,<span class="stringliteral">"\nError opening output file\n"</span>);
00085         <span class="keywordflow">return</span> -1;
00086     }
00087     
00088     printf(<span class="stringliteral">"\nlistening on %s... Press Ctrl+C to stop...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00089     
00090     <span class="comment">/* At this point, we no longer need the device list. Free it */</span>
00091     <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00092     
00093     <span class="comment">/* start the capture */</span>
00094     <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dumpfile);
00095 
00096     <span class="keywordflow">return</span> 0;
00097 }
00098 
00099 <span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
00100 <span class="keywordtype">void</span> packet_handler(u_char *dumpfile, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
00101 {
00102     <span class="comment">/* save the packet on the dump file */</span>
00103     <a class="code" href="group__wpcapfunc.html#ga17">pcap_dump</a>(dumpfile, header, pkt_data);
00104 }
</div></pre><p>
As you can see, the structure of the program is very similar to the ones we have seen in the previous lessons. The differences are:<ul>
<li>a call to <a class="el" href="group__wpcapfunc.html#ga4">pcap_dump_open()</a> is issued once the interface is opened. This call opens a dump file and associates it with the interface.</li><li>the packets are written to this file with a <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> from the packet_handler() callback. The parameters of <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a> are in 1-1 correspondence with the parameters of <a class="el" href="group__wpcapfunc.html#ga0">pcap_handler()</a>.</li></ul>
<p>
<b>Reading packets from a dump file</b><p>
Now that we have a dump file available, we can try to read its content. The following code opens a WinPcap/libpcap dump file and displays every packet contained in the file. The file is opened with <a class="el" href="group__wpcapfunc.html#ga3">pcap_open_offline()</a>, then the usual <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> is used to sequence through the packets. As you can see, reading packets from an offline capture is nearly identical to receiving them from a physical interface.<p>
This example introduces another function: pcap_createsrcsrc(). This function is required to create a source string that begins with a marker used to tell WinPcap the type of the source, e.g. "rpcap://" if we are going to open an adapter, or "file://" if we are going to open a file. This step is not required when <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> is used (the returned values already contain these strings). However, it is required in this example because the name of the file is read from the user input.<p>
<pre><div class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#ga0">PCAP_BUF_SIZE</a>];

    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }

    <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga56">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
                            PCAP_SRC_FILE,  <span class="comment">// we want to open a file</span>
                            NULL,           <span class="comment">// remote host</span>
                            NULL,           <span class="comment">// port on the remote host</span>
                            argv[1],        <span class="comment">// name of the file we want to open</span>
                            errbuf          <span class="comment">// error buffer</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Open the capture file */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(source,         <span class="comment">// name of the device</span>
                        65536,          <span class="comment">// portion of the packet to capture</span>
                                        <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                         PCAP_OPENFLAG_PROMISCUOUS,     <span class="comment">// promiscuous mode</span>
                         1000,              <span class="comment">// read timeout</span>
                         NULL,              <span class="comment">// authentication on the remote machine</span>
                         errbuf         <span class="comment">// error buffer</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">// read and dispatch packets until EOF is reached</span>
    <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(fp, 0, dispatcher_handler, NULL);

    <span class="keywordflow">return</span> 0;
}



<span class="keywordtype">void</span> dispatcher_handler(u_char *temp1, 
                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    u_int i=0;
    
    <span class="comment">/* print pkt timestamp and pkt len */</span>
    printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);          
    
    <span class="comment">/* Print the packet */</span>
    <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#o1">caplen</a> + 1 ) ; i++)
    {
        printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
        <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
    }
    
    printf(<span class="stringliteral">"\n\n"</span>);     
    
}
</div></pre><pre><div class="fragment">00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;pcap.h&gt;</span>
00003 
00004 <span class="preprocessor">#define LINE_LEN 16</span>
00005 <span class="preprocessor"></span>
00006 <span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);
00007 
00008 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00009 {
00010 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
00011 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00012 <span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#ga0">PCAP_BUF_SIZE</a>];
00013 
00014     <span class="keywordflow">if</span>(argc != 2){
00015 
00016         printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
00017         <span class="keywordflow">return</span> -1;
00018 
00019     }
00020 
00021     <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
00022     <span class="keywordflow">if</span> ( <a class="code" href="remote-ext_8h.html#a16">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
00023                             PCAP_SRC_FILE,  <span class="comment">// we want to open a file</span>
00024                             NULL,           <span class="comment">// remote host</span>
00025                             NULL,           <span class="comment">// port on the remote host</span>
00026                             argv[1],        <span class="comment">// name of the file we want to open</span>
00027                             errbuf          <span class="comment">// error buffer</span>
00028                             ) != 0)
00029     {
00030         fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
00031         <span class="keywordflow">return</span> -1;
00032     }
00033     
00034     <span class="comment">/* Open the capture file */</span>
00035     <span class="keywordflow">if</span> ( (fp= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(source,         <span class="comment">// name of the device</span>
00036                         65536,          <span class="comment">// portion of the packet to capture</span>
00037                                         <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
00038                          PCAP_OPENFLAG_PROMISCUOUS,     <span class="comment">// promiscuous mode</span>
00039                          1000,              <span class="comment">// read timeout</span>
00040                          NULL,              <span class="comment">// authentication on the remote machine</span>
00041                          errbuf         <span class="comment">// error buffer</span>
00042                          ) ) == NULL)
00043     {
00044         fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
00045         <span class="keywordflow">return</span> -1;
00046     }
00047 
00048     <span class="comment">// read and dispatch packets until EOF is reached</span>
00049     <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(fp, 0, dispatcher_handler, NULL);
00050 
00051     <span class="keywordflow">return</span> 0;
00052 }
00053 
00054 
00055 
00056 <span class="keywordtype">void</span> dispatcher_handler(u_char *temp1, 
00057                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
00058 {
00059     u_int i=0;
00060     
00061     <span class="comment">/* print pkt timestamp and pkt len */</span>
00062     printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);          
00063     
00064     <span class="comment">/* Print the packet */</span>
00065     <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#o1">caplen</a> + 1 ) ; i++)
00066     {
00067         printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
00068         <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
00069     }
00070     
00071     printf(<span class="stringliteral">"\n\n"</span>);     
00072     
00073 }
</div></pre><p>
The following example has the same purpose of the last one, but <a class="el" href="group__wpcapfunc.html#ga14">pcap_next_ex()</a> is used instead of the <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> callback method.<p>
<pre><div class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#ga0">PCAP_BUF_SIZE</a>];
<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header;
u_char *pkt_data;
u_int i=0;
<span class="keywordtype">int</span> res;

    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga56">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
                            PCAP_SRC_FILE,  <span class="comment">// we want to open a file</span>
                            NULL,           <span class="comment">// remote host</span>
                            NULL,           <span class="comment">// port on the remote host</span>
                            argv[1],        <span class="comment">// name of the file we want to open</span>
                            errbuf          <span class="comment">// error buffer</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Open the capture file */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(source,         <span class="comment">// name of the device</span>
                        65536,          <span class="comment">// portion of the packet to capture</span>
                                        <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                         PCAP_OPENFLAG_PROMISCUOUS,     <span class="comment">// promiscuous mode</span>
                         1000,              <span class="comment">// read timeout</span>
                         NULL,              <span class="comment">// authentication on the remote machine</span>
                         errbuf         <span class="comment">// error buffer</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Retrieve the packets from the file */</span>
    <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcapfunc.html#ga14">pcap_next_ex</a>( fp, &amp;header, &amp;pkt_data)) &gt;= 0)
    {
        <span class="comment">/* print pkt timestamp and pkt len */</span>
        printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;ts.tv_sec, header-&gt;ts.tv_usec, header-&gt;len);          
        
        <span class="comment">/* Print the packet */</span>
        <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;caplen + 1 ) ; i++)
        {
            printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
            <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
        }
        
        printf(<span class="stringliteral">"\n\n"</span>);     
    }
    
    
    <span class="keywordflow">if</span> (res == -1)
    {
        printf(<span class="stringliteral">"Error reading the packets: %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
    }
    
    <span class="keywordflow">return</span> 0;
}

</div></pre><pre><div class="fragment">00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;pcap.h&gt;</span>
00003 
00004 <span class="preprocessor">#define LINE_LEN 16</span>
00005 <span class="preprocessor"></span>
00006 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00007 {
00008 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
00009 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00010 <span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#ga0">PCAP_BUF_SIZE</a>];
00011 <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header;
00012 u_char *pkt_data;
00013 u_int i=0;
00014 <span class="keywordtype">int</span> res;
00015 
00016     <span class="keywordflow">if</span>(argc != 2)
00017     {
00018         printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
00019         <span class="keywordflow">return</span> -1;
00020     }
00021     
00022     <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
00023     <span class="keywordflow">if</span> ( <a class="code" href="remote-ext_8h.html#a16">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
00024                             PCAP_SRC_FILE,  <span class="comment">// we want to open a file</span>
00025                             NULL,           <span class="comment">// remote host</span>
00026                             NULL,           <span class="comment">// port on the remote host</span>
00027                             argv[1],        <span class="comment">// name of the file we want to open</span>
00028                             errbuf          <span class="comment">// error buffer</span>
00029                             ) != 0)
00030     {
00031         fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
00032         <span class="keywordflow">return</span> -1;
00033     }
00034     
00035     <span class="comment">/* Open the capture file */</span>
00036     <span class="keywordflow">if</span> ( (fp= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(source,         <span class="comment">// name of the device</span>
00037                         65536,          <span class="comment">// portion of the packet to capture</span>
00038                                         <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
00039                          PCAP_OPENFLAG_PROMISCUOUS,     <span class="comment">// promiscuous mode</span>
00040                          1000,              <span class="comment">// read timeout</span>
00041                          NULL,              <span class="comment">// authentication on the remote machine</span>
00042                          errbuf         <span class="comment">// error buffer</span>
00043                          ) ) == NULL)
00044     {
00045         fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
00046         <span class="keywordflow">return</span> -1;
00047     }
00048     
00049     <span class="comment">/* Retrieve the packets from the file */</span>
00050     <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcapfunc.html#ga14">pcap_next_ex</a>( fp, &amp;header, &amp;pkt_data)) &gt;= 0)
00051     {
00052         <span class="comment">/* print pkt timestamp and pkt len */</span>
00053         printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;ts.tv_sec, header-&gt;ts.tv_usec, header-&gt;len);          
00054         
00055         <span class="comment">/* Print the packet */</span>
00056         <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;caplen + 1 ) ; i++)
00057         {
00058             printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
00059             <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
00060         }
00061         
00062         printf(<span class="stringliteral">"\n\n"</span>);     
00063     }
00064     
00065     
00066     <span class="keywordflow">if</span> (res == -1)
00067     {
00068         printf(<span class="stringliteral">"Error reading the packets: %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
00069     }
00070     
00071     <span class="keywordflow">return</span> 0;
00072 }
00073 
</div></pre><p>
<b>Writing packets to a dump file with pcap_live_dump</b><p>
<b>NOTE:</b> At the moment, due to some problems with the new kernel buffer, this feature has been disabled.<p>
Recent versions of WinPcap provide a further way to save network traffic to disk, the <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> function. <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> takes three parameters: a file name, the maximum size (in bytes) that this file is allowed to reach and the maximum amount of packets that the file is allowed to contain. Zero means no limit for both these values. Notice that the program can set a filter (with <a class="el" href="group__wpcapfunc.html#ga21">pcap_setfilter()</a>, see the tutorial <a class="el" href="group__wpcap__tut5.html">Filtering the traffic</a>) before calling <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> to define the subset of the traffic that will be saved.<p>
<a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> is non-blocking, therefore it starts the dump and returns immediately: The dump process goes on asynchronously until the maximum file size or the maximum amount of packets has been reached.<p>
The application can wait or check the end of the dump with <a class="el" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended()</a>. <b>Beware</b> that if the <em>sync</em> parameter is nonzero, this function will block your application forever if the limits are both 0.<p>
<pre><div class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2002</span>
<span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
<span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
<span class="comment"> * distributions including binary code include the above copyright notice and</span>
<span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
<span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
<span class="comment"> * features or use of this software display the following acknowledgement:</span>
<span class="comment"> * ``This product includes software developed by the Politecnico</span>
<span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
<span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
<span class="comment"> * or promote products derived from this software without specific prior</span>
<span class="comment"> * written permission.</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
<span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
<span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#error At the moment the kernel dump feature is not supported in the driver</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs, *d;
    <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
    u_int inum, i=0;
    <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];

    printf(<span class="stringliteral">"kdump: saves the network traffic to file using WinPcap kernel-level dump faeature.\n"</span>);
    printf(<span class="stringliteral">"\t Usage: %s [adapter] | dump_file_name max_size max_packs\n"</span>, argv[0]);
    printf(<span class="stringliteral">"\t Where: max_size is the maximum size that the dump file will reach (0 means no limit)\n"</span>);
    printf(<span class="stringliteral">"\t Where: max_packs is the maximum number of packets that will be saved (0 means no limit)\n\n"</span>);


    <span class="keywordflow">if</span>(argc &lt; 5){

        <span class="comment">/* The user didn't provide a packet source: Retrieve the device list */</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
        {
            fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
            exit(1);
        }
        
        <span class="comment">/* Print the list */</span>
        <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
        {
            printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
            <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
                printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
            <span class="keywordflow">else</span>
                printf(<span class="stringliteral">" (No description available)\n"</span>);
        }
        
        <span class="keywordflow">if</span>(i==0)
        {
            printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
            <span class="keywordflow">return</span> -1;
        }
        
        printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
        scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
        
        <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
        {
            printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
            <span class="comment">/* Free the device list */</span>
            <span class="keywordflow">return</span> -1;
        }
        
        <span class="comment">/* Jump to the selected adapter */</span>
        <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
        
        <span class="comment">/* Open the device */</span>
        <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcapfunc.html#ga1">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>, 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);

        <span class="comment">/* Start the dump */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#ga44">pcap_live_dump</a>(fp, argv[1], atoi(argv[2]), atoi(argv[3]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }
    <span class="keywordflow">else</span>{
        
        <span class="comment">/* Open the device */</span>
        <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#ga1">pcap_open_live</a>(argv[1], 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* Start the dump */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#ga44">pcap_live_dump</a>(fp, argv[0], atoi(argv[1]), atoi(argv[2]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }

    <span class="comment">/* Wait until the dump finishes, i.e. when  max_size or max_packs is reached*/</span>
    <a class="code" href="group__wpcapfunc.html#ga45">pcap_live_dump_ended</a>(fp, TRUE);
    
    <span class="comment">/* Close the adapter, so that the file is correctly flushed */</span>
    <a class="code" href="group__wpcapfunc.html#ga39">pcap_close</a>(fp);

    <span class="keywordflow">return</span> 0;
}
</div></pre><pre><div class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 - 2002</span>
00003 <span class="comment"> *  Politecnico di Torino.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
00012 <span class="comment"> * ``This product includes software developed by the Politecnico</span>
00013 <span class="comment"> * di Torino, and its contributors.'' Neither the name of</span>
00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
00016 <span class="comment"> * written permission.</span>
00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED</span>
00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00023 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00024 
00025 <span class="preprocessor">#include &lt;pcap.h&gt;</span>
00026 
00027 <span class="preprocessor">#error At the moment the kernel dump feature is not supported in the driver</span>
00028 <span class="preprocessor"></span>
00029 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
00030     
00031     <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs, *d;
00032     <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
00033     u_int inum, i=0;
00034     <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00035 
00036     printf(<span class="stringliteral">"kdump: saves the network traffic to file using WinPcap kernel-level dump faeature.\n"</span>);
00037     printf(<span class="stringliteral">"\t Usage: %s [adapter] | dump_file_name max_size max_packs\n"</span>, argv[0]);
00038     printf(<span class="stringliteral">"\t Where: max_size is the maximum size that the dump file will reach (0 means no limit)\n"</span>);
00039     printf(<span class="stringliteral">"\t Where: max_packs is the maximum number of packets that will be saved (0 means no limit)\n\n"</span>);
00040 
00041 
00042     <span class="keywordflow">if</span>(argc &lt; 5){
00043 
00044         <span class="comment">/* The user didn't provide a packet source: Retrieve the device list */</span>
00045         <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga7">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
00046         {
00047             fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
00048             exit(1);
00049         }
00050         
00051         <span class="comment">/* Print the list */</span>
00052         <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
00053         {
00054             printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00055             <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
00056                 printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00057             <span class="keywordflow">else</span>
00058                 printf(<span class="stringliteral">" (No description available)\n"</span>);
00059         }
00060         
00061         <span class="keywordflow">if</span>(i==0)
00062         {
00063             printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
00064             <span class="keywordflow">return</span> -1;
00065         }
00066         
00067         printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
00068         scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
00069         
00070         <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
00071         {
00072             printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
00073             <span class="comment">/* Free the device list */</span>
00074             <span class="keywordflow">return</span> -1;
00075         }
00076         
00077         <span class="comment">/* Jump to the selected adapter */</span>
00078         <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
00079         
00080         <span class="comment">/* Open the device */</span>
00081         <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcapfunc.html#ga1">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>, 100, 1, 20, errbuf) ) == NULL)
00082         {
00083             fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
00084             <span class="keywordflow">return</span> -1;
00085         }
00086 
00087         <span class="comment">/* Free the device list */</span>
00088         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00089 
00090         <span class="comment">/* Start the dump */</span>
00091         <span class="keywordflow">if</span>(<a class="code" href="Win32-Extensions_8h.html#a25">pcap_live_dump</a>(fp, argv[1], atoi(argv[2]), atoi(argv[3]))==-1){
00092             printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
00093             <span class="keywordflow">return</span> -1;
00094         }
00095     }
00096     <span class="keywordflow">else</span>{
00097         
00098         <span class="comment">/* Open the device */</span>
00099         <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#ga1">pcap_open_live</a>(argv[1], 100, 1, 20, errbuf) ) == NULL)
00100         {
00101             fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
00102             <span class="keywordflow">return</span> -1;
00103         }
00104 
00105         <span class="comment">/* Start the dump */</span>
00106         <span class="keywordflow">if</span>(<a class="code" href="Win32-Extensions_8h.html#a25">pcap_live_dump</a>(fp, argv[0], atoi(argv[1]), atoi(argv[2]))==-1){
00107             printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#ga36">pcap_geterr</a>(fp));
00108             <span class="keywordflow">return</span> -1;
00109         }
00110     }
00111 
00112     <span class="comment">/* Wait until the dump finishes, i.e. when  max_size or max_packs is reached*/</span>
00113     <a class="code" href="Win32-Extensions_8h.html#a26">pcap_live_dump_ended</a>(fp, TRUE);
00114     
00115     <span class="comment">/* Close the adapter, so that the file is correctly flushed */</span>
00116     <a class="code" href="group__wpcapfunc.html#ga39">pcap_close</a>(fp);
00117 
00118     <span class="keywordflow">return</span> 0;
00119 }
</div></pre><p>
The difference between <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> and <a class="el" href="group__wpcapfunc.html#ga17">pcap_dump()</a>, apart from the possibility to set limits, is performance. <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> exploits the ability of the WinPcap NPF driver (see <a class="el" href="group__NPF.html">NPF driver internals manual</a>) to write dumps from kernel level, minimizing the number of context switches and memory copies.<p>
Obviously, since this feature is currently not available on other operating systems, <a class="el" href="group__wpcapfunc.html#ga44">pcap_live_dump()</a> is WinPcap specific and is present only under Win32.<p>
<a class="el" href="group__wpcap__tut6.html">&lt;&lt;&lt; Previous</a> <a class="el" href="group__wpcap__tut8.html">Next &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
