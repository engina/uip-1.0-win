<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Interpreting the packets</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Interpreting the packets<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to using WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Now that we are able to capture and filter network traffic, we want to put our knowledge to work with a simple "real world" application.<p>
In this lesson we will take code from the previous lessons and use these pieces to build a more useful program. the main purpose of the current program is to show how the protocol headers of a captured packet can be parsed and interpreted. The resulting application, called UDPdump, prints a summary of the UDP traffic on our network.<p>
We have chosen to parse and display the UDP protocol because it is more accessible than other protocols such as TCP and consequently is an excellent initial example. Let's look at the code:<p>
<pre><div class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2003</span>
<span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> * </span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
<span class="comment"> * modification, are permitted provided that the following conditions </span>
<span class="comment"> * are met:</span>
<span class="comment"> * </span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
<span class="comment"> * documentation and/or other materials provided with the distribution. </span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
<span class="comment"> * contributors may be used to endorse or promote products derived from </span>
<span class="comment"> * this software without specific prior written permission. </span>
<span class="comment"> * </span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> * </span>
<span class="comment"> */</span>


<span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* 4 bytes IP address */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_address{
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
}ip_address;

<span class="comment">/* IPv4 header */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_header{
    u_char  ver_ihl;        <span class="comment">// Version (4 bits) + Internet header length (4 bits)</span>
    u_char  tos;            <span class="comment">// Type of service </span>
    u_short tlen;           <span class="comment">// Total length </span>
    u_short identification; <span class="comment">// Identification</span>
    u_short flags_fo;       <span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span>
    u_char  ttl;            <span class="comment">// Time to live</span>
    u_char  proto;          <span class="comment">// Protocol</span>
    u_short crc;            <span class="comment">// Header checksum</span>
    ip_address  saddr;      <span class="comment">// Source address</span>
    ip_address  daddr;      <span class="comment">// Destination address</span>
    u_int   op_pad;         <span class="comment">// Option + Padding</span>
}ip_header;

<span class="comment">/* UDP header*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>udp_header{
    u_short sport;          <span class="comment">// Source port</span>
    u_short dport;          <span class="comment">// Destination port</span>
    u_short len;            <span class="comment">// Datagram length</span>
    u_short crc;            <span class="comment">// Checksum</span>
}udp_header;

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);


main()
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
u_int netmask;
<span class="keywordtype">char</span> packet_filter[] = <span class="stringliteral">"ip and udp"</span>;
<span class="keyword">struct </span>bpf_program fcode;

    <span class="comment">/* Retrieve the device list */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
    
    <span class="comment">/* Open the adapter */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,  <span class="comment">// name of the device</span>
                             65536,     <span class="comment">// portion of the packet to capture. </span>
                                        <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span>
                             PCAP_OPENFLAG_PROMISCUOUS,         <span class="comment">// promiscuous mode</span>
                             1000,      <span class="comment">// read timeout</span>
                             NULL,      <span class="comment">// remote authentication</span>
                             errbuf     <span class="comment">// error buffer</span>
                             ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#ga23">pcap_datalink</a>(adhandle) != DLT_EN10MB)
    {
        fprintf(stderr,<span class="stringliteral">"\nThis program works only on Ethernet networks.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="keywordflow">if</span>(d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a> != NULL)
        <span class="comment">/* Retrieve the mask of the first address of the interface */</span>
        netmask=((<span class="keyword">struct </span>sockaddr_in *)(d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a>-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>))-&gt;sin_addr.S_un.S_addr;
    <span class="keywordflow">else</span>
        <span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span>
        netmask=0xffffff; 


    <span class="comment">//compile the filter</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga19">pcap_compile</a>(adhandle, &amp;fcode, packet_filter, 1, netmask) &lt;0 )
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">//set the filter</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga21">pcap_setfilter</a>(adhandle, &amp;fcode)&lt;0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
    
    <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
    <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    ip_header *ih;
    udp_header *uh;
    u_int ip_len;
    u_short sport,dport;

    <span class="comment">/* convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* print timestamp and length of the packet */</span>
    printf(<span class="stringliteral">"%s.%.6d len:%d "</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);

    <span class="comment">/* retireve the position of the ip header */</span>
    ih = (ip_header *) (pkt_data +
        14); <span class="comment">//length of ethernet header</span>

    <span class="comment">/* retireve the position of the udp header */</span>
    ip_len = (ih-&gt;ver_ihl &amp; 0xf) * 4;
    uh = (udp_header *) ((u_char*)ih + ip_len);

    <span class="comment">/* convert from network byte order to host byte order */</span>
    sport = ntohs( uh-&gt;sport );
    dport = ntohs( uh-&gt;dport );

    <span class="comment">/* print ip addresses and udp ports */</span>
    printf(<span class="stringliteral">"%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n"</span>,
        ih-&gt;saddr.byte1,
        ih-&gt;saddr.byte2,
        ih-&gt;saddr.byte3,
        ih-&gt;saddr.byte4,
        sport,
        ih-&gt;daddr.byte1,
        ih-&gt;daddr.byte2,
        ih-&gt;daddr.byte3,
        ih-&gt;daddr.byte4,
        dport);
}
</div></pre><pre><div class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 
00034 <span class="preprocessor">#include "pcap.h"</span>
00035 
00036 <span class="comment">/* 4 bytes IP address */</span>
00037 <span class="keyword">typedef</span> <span class="keyword">struct </span>ip_address{
00038     u_char byte1;
00039     u_char byte2;
00040     u_char byte3;
00041     u_char byte4;
00042 }ip_address;
00043 
00044 <span class="comment">/* IPv4 header */</span>
00045 <span class="keyword">typedef</span> <span class="keyword">struct </span>ip_header{
00046     u_char  ver_ihl;        <span class="comment">// Version (4 bits) + Internet header length (4 bits)</span>
00047     u_char  tos;            <span class="comment">// Type of service </span>
00048     u_short tlen;           <span class="comment">// Total length </span>
00049     u_short identification; <span class="comment">// Identification</span>
00050     u_short flags_fo;       <span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span>
00051     u_char  ttl;            <span class="comment">// Time to live</span>
00052     u_char  proto;          <span class="comment">// Protocol</span>
00053     u_short crc;            <span class="comment">// Header checksum</span>
00054     ip_address  saddr;      <span class="comment">// Source address</span>
00055     ip_address  daddr;      <span class="comment">// Destination address</span>
00056     u_int   op_pad;         <span class="comment">// Option + Padding</span>
00057 }ip_header;
00058 
00059 <span class="comment">/* UDP header*/</span>
00060 <span class="keyword">typedef</span> <span class="keyword">struct </span>udp_header{
00061     u_short sport;          <span class="comment">// Source port</span>
00062     u_short dport;          <span class="comment">// Destination port</span>
00063     u_short len;            <span class="comment">// Datagram length</span>
00064     u_short crc;            <span class="comment">// Checksum</span>
00065 }udp_header;
00066 
00067 <span class="comment">/* prototype of the packet handler */</span>
00068 <span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);
00069 
00070 
00071 main()
00072 {
00073 <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
00074 <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
00075 <span class="keywordtype">int</span> inum;
00076 <span class="keywordtype">int</span> i=0;
00077 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
00078 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00079 u_int netmask;
00080 <span class="keywordtype">char</span> packet_filter[] = <span class="stringliteral">"ip and udp"</span>;
00081 <span class="keyword">struct </span>bpf_program fcode;
00082 
00083     <span class="comment">/* Retrieve the device list */</span>
00084     <span class="keywordflow">if</span> (<a class="code" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
00085     {
00086         fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
00087         exit(1);
00088     }
00089     
00090     <span class="comment">/* Print the list */</span>
00091     <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
00092     {
00093         printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00094         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
00095             printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00096         <span class="keywordflow">else</span>
00097             printf(<span class="stringliteral">" (No description available)\n"</span>);
00098     }
00099 
00100     <span class="keywordflow">if</span>(i==0)
00101     {
00102         printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
00103         <span class="keywordflow">return</span> -1;
00104     }
00105     
00106     printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
00107     scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
00108     
00109     <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
00110     {
00111         printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
00112         <span class="comment">/* Free the device list */</span>
00113         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00114         <span class="keywordflow">return</span> -1;
00115     }
00116 
00117     <span class="comment">/* Jump to the selected adapter */</span>
00118     <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
00119     
00120     <span class="comment">/* Open the adapter */</span>
00121     <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,  <span class="comment">// name of the device</span>
00122                              65536,     <span class="comment">// portion of the packet to capture. </span>
00123                                         <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span>
00124                              PCAP_OPENFLAG_PROMISCUOUS,         <span class="comment">// promiscuous mode</span>
00125                              1000,      <span class="comment">// read timeout</span>
00126                              NULL,      <span class="comment">// remote authentication</span>
00127                              errbuf     <span class="comment">// error buffer</span>
00128                              ) ) == NULL)
00129     {
00130         fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
00131         <span class="comment">/* Free the device list */</span>
00132         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00133         <span class="keywordflow">return</span> -1;
00134     }
00135     
00136     <span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span>
00137     <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#ga23">pcap_datalink</a>(adhandle) != DLT_EN10MB)
00138     {
00139         fprintf(stderr,<span class="stringliteral">"\nThis program works only on Ethernet networks.\n"</span>);
00140         <span class="comment">/* Free the device list */</span>
00141         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00142         <span class="keywordflow">return</span> -1;
00143     }
00144     
00145     <span class="keywordflow">if</span>(d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a> != NULL)
00146         <span class="comment">/* Retrieve the mask of the first address of the interface */</span>
00147         netmask=((<span class="keyword">struct </span>sockaddr_in *)(d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a>-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>))-&gt;sin_addr.S_un.S_addr;
00148     <span class="keywordflow">else</span>
00149         <span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span>
00150         netmask=0xffffff; 
00151 
00152 
00153     <span class="comment">//compile the filter</span>
00154     <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga19">pcap_compile</a>(adhandle, &amp;fcode, packet_filter, 1, netmask) &lt;0 )
00155     {
00156         fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
00157         <span class="comment">/* Free the device list */</span>
00158         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00159         <span class="keywordflow">return</span> -1;
00160     }
00161     
00162     <span class="comment">//set the filter</span>
00163     <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga21">pcap_setfilter</a>(adhandle, &amp;fcode)&lt;0)
00164     {
00165         fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
00166         <span class="comment">/* Free the device list */</span>
00167         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00168         <span class="keywordflow">return</span> -1;
00169     }
00170     
00171     printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00172     
00173     <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
00174     <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00175     
00176     <span class="comment">/* start the capture */</span>
00177     <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
00178     
00179     <span class="keywordflow">return</span> 0;
00180 }
00181 
00182 <span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
00183 <span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
00184 {
00185     <span class="keyword">struct </span>tm *ltime;
00186     <span class="keywordtype">char</span> timestr[16];
00187     ip_header *ih;
00188     udp_header *uh;
00189     u_int ip_len;
00190     u_short sport,dport;
00191 
00192     <span class="comment">/* convert the timestamp to readable format */</span>
00193     ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
00194     strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);
00195 
00196     <span class="comment">/* print timestamp and length of the packet */</span>
00197     printf(<span class="stringliteral">"%s.%.6d len:%d "</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);
00198 
00199     <span class="comment">/* retireve the position of the ip header */</span>
00200     ih = (ip_header *) (pkt_data +
00201         14); <span class="comment">//length of ethernet header</span>
00202 
00203     <span class="comment">/* retireve the position of the udp header */</span>
00204     ip_len = (ih-&gt;ver_ihl &amp; 0xf) * 4;
00205     uh = (udp_header *) ((u_char*)ih + ip_len);
00206 
00207     <span class="comment">/* convert from network byte order to host byte order */</span>
00208     sport = ntohs( uh-&gt;sport );
00209     dport = ntohs( uh-&gt;dport );
00210 
00211     <span class="comment">/* print ip addresses and udp ports */</span>
00212     printf(<span class="stringliteral">"%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n"</span>,
00213         ih-&gt;saddr.byte1,
00214         ih-&gt;saddr.byte2,
00215         ih-&gt;saddr.byte3,
00216         ih-&gt;saddr.byte4,
00217         sport,
00218         ih-&gt;daddr.byte1,
00219         ih-&gt;daddr.byte2,
00220         ih-&gt;daddr.byte3,
00221         ih-&gt;daddr.byte4,
00222         dport);
00223 }
</div></pre><p>
First of all, we set the filter to "ip and udp". In this way we are sure that packet_handler() will receive only UDP packets over IPv4: this simplifies the parsing and increases the efficiency of the program.<p>
We have also created a couple of structs that describe the IP and UDP headers. These structs are used by packet_handler() to properly locate the various header fields.<p>
packet_handler(), although limited to a single protocol dissector (UDP over IPv4), shows how complex "sniffers" like tcpdump/WinDump decode the network traffic. Since we aren't interested in the MAC header, we skip it. For simplicity and before starting the capture, we check the MAC layer with <a class="el" href="group__wpcapfunc.html#ga23">pcap_datalink()</a> to make sure that we are dealing with an Ethernet network. This way we can be sure that the MAC header is exactly 14 bytes.<p>
The IP header is located just after the MAC header. We will extract the IP source and destination addresses from the IP header.<p>
Reaching the UDP header is a bit more complicated, because the IP header doesn't have a fixed length. Therefore, we use the IP header's length field to know its size. Once we know the location of the UDP header, we extract the source and destination ports.<p>
The extracted values are printed on the screen, and the result is something like:<p>
<code> 1. {A7FD048A-5D4B-478E-B3C1-34401AC3B72F} (Xircom t 10/100 Adapter) <br>
 Enter the interface number (1-2):1<br>
</code><p>
<code>listening on Xircom CardBus Ethernet 10/100 Adapter... <br>
 16:13:15.312784 len:87 130.192.31.67.2682 -&gt; 130.192.3.21.53 <br>
 16:13:15.314796 len:137 130.192.3.21.53 -&gt; 130.192.31.67.2682 <br>
 16:13:15.322101 len:78 130.192.31.67.2683 -&gt; 130.192.3.21.53 <br>
 </code><p>
Each of the final 3 lines represents a different packet.<p>
<a class="el" href="group__wpcap__tut5.html">&lt;&lt;&lt; Previous</a> <a class="el" href="group__wpcap__tut7.html">Next &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
